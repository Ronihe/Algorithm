## what is stack:
LIFO:

- push()，将新的元素压入栈顶，同时栈顶上升。
- pop()，将新的元素弹出栈顶，同时栈顶下降。
- empty()，栈是否为空。
- peek()，返回栈顶元素。

```commandline
class Stack:
    def __init__(self):
        self.array = []
				
    # 压入新元素
    def push(self, x):
        self.array.append(x)
    
    # 栈顶元素出栈
    def pop(self):
        if not self.isEmpty():
            self.array.pop()
	
    # 返回栈顶元素
    def top(self):
        return self.array[-1]

    # 判断是否是空栈
    def isEmpty(self):
        return len(self.array) == 0
```
栈在计算机内存当中的应用

我们在程序运行时，常说的内存中的堆栈，其实就是栈空间。这一段空间存放着程序运行时，产生的各种临时变量、函数调用，一旦这些内容失去其作用域，就会被自动销毁。

函数调用其实是栈的很好的例子，后调用的函数先结束，所以为了调用函数，所需要的内存结构，栈是再合适不过了。在内存当中，栈从高地址不断向低地址扩展，随着程序运行的层层深入，栈顶指针不断指向内存中更低的地址。

相关参考资料：
https://blog.csdn.net/liu_yude/article/details/45058687

## 内存的分配
1. 栈区： compiler 自动分配释放， variables， 局部变量。
2. heap 堆区: 有程序员分配释放， 若程序员不释放， 程序结束时可能由OS回收。 与数据结构中的堆是两回事，分配方式类似于列表。
3. static 静态区， 全局变量和静态变量在一块区域。未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。
4. 文字常量区 - 常量字符串， 程序结束后由系统释放
5. 程序代码区 - 存放二进制函数

## 堆和栈的理论知识 
stack： 由系统自动分配。 例如，声明在函数中一个局部变量 int b; 系统自动在栈中为b开辟空间 

heap： 需要程序员自己申请，并指明大小，在c中malloc函数 

## 申请后系统的响应 
栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。 

堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时， 


