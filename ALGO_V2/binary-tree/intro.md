## Traversal:
- visit the node in the data structure
1. 层序遍历（Level order）
2. 先序遍历（Pre order）
3. 中序遍历（In order）
4. 后序遍历（Post order）

我们在之前的课程中，已经学习过了二叉树的层序遍历，也就是使用 BFS 算法来获得二叉树的分层信息。通过 BFS 获得的顺序我们也可以称之为 BFS Order。而剩下的三种遍历，都需要通过深度优先搜索的方式来获得。而这一小节中，我们将讲一下通过深度优先搜索（DFS）来获得的节点顺序，

先序遍历 / 中序遍历 / 后序遍历

### 先序遍历（又叫先根遍历、前序遍历）
首先访问根结点，然后遍历左子树，最后遍历右子树。遍历左、右子树时，仍按先序遍历。若二叉树为空则返回。

该过程可简记为根左右，注意该过程是递归的。如图先序遍历结果是：ABDECF。
```
# 将根作为root，空list作为result传入，即可得到整棵树的遍历结果
def traverse(root, result):
    if not root:
        return
    result.append(root.val)
    traverse(root.left, result)
    traverse(root.right, result)
```
### 中序遍历（又叫中根遍历）
首先遍历左子树，然后访问根结点，最后遍历右子树。遍历左、右子树时，仍按中序遍历。若二叉树为空则返回。简记为左根右。
上图中序遍历结果是：DBEAFC。
```

def traverse(root, result):
    if not root:
        return
    traverse(root.left, result)
    result.append(root.val) # 注意访问根节点放到了遍历左子树的后面
    traverse(root.right, result)

```
### 后序遍历（又叫后根遍历）
首先遍历左子树，然后遍历右子树，最后访问根结点。遍历左、右子树时，仍按后序遍历。若二叉树为空则返回。简记为左右根。
上图后序遍历结果是：DEBFCA。
 
 ```
def traverse(root, result):
    if not root:
        return
    traverse(root.left, result)
    traverse(root.right, result)
    result.append(root.val) # 注意访问根节点放到了最后
```

定义
分治法（Divide & Conquer Algorithm）是说将一个大问题，拆分为2个或者多个小问题，当小问题得到结果之后，合并他们的结果来得到大问题的结果。

举一个例子，比如中国要进行人口统计。那么如果使用遍历（Traversal）的办法，做法如下：

人口普查员小张自己一个人带着一个本子，跑遍全中国挨家挨户的敲门查户口

而如果使用分治法，做法如下：

国家统计局的老板小李想要知道全国人口的总数，于是他找来全国各个省的统计局领导，下派人口普查任务给他们，让他们各自去统计自己省的人口总数。在小李这儿，他只需要最后将各个省汇报的人口总数结果累加起来，就得到了全国人口的数目。
然后每个省的领导，又找来省里各个市的领导，让各个市去做人口统计。
市找县，县找镇，镇找乡。最后乡里的干部小王挨家挨户敲门去查户口。
在这里，把全国的任务拆分为省级的任务的过程，就是分治法中分的这个步骤。把各个小任务派发给别人去完成的过程，就是分治法中治的这个步骤。但是事实上我们还有第三个步骤，就是将小任务的结果合并到一起的过程，合这个步骤。因此如果我来取名字的话，我会叫这个算法：分治合算法。

为什么二叉树的问题适合使用分治法？
在一棵二叉树（Binary Tree）中，如果将整棵二叉树看做一个大问题的话，那么根节点（Root）的左子树（Left subtree）就是一个小问题，右子树（Right subtree）是另外一个小问题。这是一个天然就帮你完成了“分”这个步骤的数据结构

## 遍历法和分治法实战
这一小节中，我们通过如下的一些较为简单的练习题，来学习和对比遍历法和分治法：

二叉树最大深度
判断平衡二叉树
判断排序二叉树

递归，分治法，遍历法的联系与区别
联系
分治法（Divide & Conquer）与遍历法（Traverse）是两种常见的递归（Recursion）方法。

分治法解决问题的思路
先让左右子树去解决同样的问题，然后得到结果之后，再整合为整棵树的结果。

遍历法解决问题的思路
通过前序/中序/后序的某种遍历，游走整棵树，通过一个全局变量或者传递的参数来记录这个过程中所遇到的点和需要计算的结果。

两种方法的区别
从程序实现角度分治法的递归函数，通常有一个返回值，遍历法通常没有。

## 递归、回溯和搜索

什么是递归 (Recursion) ？
很多书上会把递归（Recursion）当作一种算法。事实上，递归是包含两个层面的意思的：

一种由大化小，由小化无的解决问题的算法。类似的算法还有动态规划（Dynamic Programming）。
一种程序的实现方式。这种方式就是一个函数（Function / Method / Procedure）自己调用自己。
与之对应的，有非递归（Non-Recursion）和迭代法（Iteration），你可以认为这两个概念是一样的概念（番茄和西红柿的区别）。不需要做区分。

什么是搜索 (Search)？
搜索分为深度优先搜索（Depth First Search）和宽度优先搜索（Breadth First Search），通常分别简写为 DFS 和 BFS。搜索是一种类似于枚举（Enumerate）的算法。比如我们需要找到一个数组里的最大值，我们可以采用枚举法，因为我们知道数组的范围和大小，比如经典的打擂台算法：
```buildoutcfg
max_num = nums[0]
for i in range(1, len(nums)):
    max_num = max(max_num, nums[i])

```
枚举法通常是你知道循环的范围，然后可以用几重循环就搞定的算法。比如我需要找到 所有 x^2 + y^2 = K 的整数组合，可以用两重循环的枚举法：
```buildoutcfg
for x in range(1, k+1):
    for y in range(1, k+1):
        if x*x + y*y == k:
            # print x and y
```
而有的问题，比如求 N 个数的全排列，你可能需要用 N 重循环才能解决。这个时候，我们就倾向于采用递归的方式去实现这个变化的 N 重循环。这个时候，我们就把算法称之为搜索。因为你已经不能明确的写出一个不依赖于输入数据的多重循环了。

通常来说 DFS 我们会采用递归的方式实现（当然你强行写一个非递归的版本也是可以的），而 BFS 则无需递归（使用队列 Queue + 哈希表 HashMap就可以）。所以我们在面试中，如果一个问题既可以使用 DFS，又可以使用 BFS 的情况下，一定要优先使用 BFS。因为他是非递归的，而且更容易实现。

## 什么是回溯(Backtracking)？
有的时候，深度优先搜索算法（DFS），又被称之为回溯法，所以你可以完全认为回溯法，就是深度优先搜索算法。在我的理解中，回溯实际上是深度优先搜索过程中的一个步骤。比如我们在进行全子集问题的搜索时，假如当前的集合是 {1,2} 代表我正在寻找以 {1,2}开头的所有集合。那么他的下一步，会去寻找 {1,2,3}开头的所有集合，然后当我们找完所有以 {1,2,3} 开头的集合时，我们需要把 3 从集合中删掉，回到 {1,2}。然后再把 4 放进去，寻找以 {1,2,4} 开头的所有集合。这个把 3 删掉回到 {1,2} 的过程，就是回溯。
```
subset.add(nums[i])
subsetsHelper(result, subset, nums, i + 1)
subset.remove(len(list) - 1)

```




















